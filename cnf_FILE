/*cnf文件读取函数*/
status ReadFile(SNode *ps, char filename[100])
{
    char ch;
    FILE *fp = NULL;
    CNode *pc, *pc_new;
    LNode *pl, *pl_new;
    int buffer = 0;
    if (((fp = fopen(filename, "r")) == NULL))
    {
        printf("Fail to open cnf File!\n");
        return FALSE;
    }
    else
    {
        printf("\n所读取的cnf文件中的注释内容:\n");
        while (fread(&ch, sizeof(char), 1, fp))
        {
            if (ch != 'p')
                printf("%c", ch);
            else
                break;
        }
    }
    for (int i = 0; i < 5; i++)
        fread(&ch, sizeof(char), 1, fp);
    fscanf(fp, "%d", &var_num);
    fscanf(fp, "%d", &sen_num);
    printf("cnf文件中的文字数:%d    子句数:     %d\n", var_num, sen_num);

    int flag_letter_1st = 1, flag_clause_1st = 1, flag_newC = 1;
    while (fscanf(fp, "%d", &buffer) != EOF)
    {
        //读取文字,读取值非0时，生成文字结点
        if (buffer)
        {
            pl_new = (LNode *)malloc(sizeof(LNode));
            pl_new->data = buffer;
            pl_new->nextL = NULL;
        }
        //读取值为0时生成下一子句
        else
        {
            flag_letter_1st = 1;
            flag_newC = 1;
            pl->nextL = NULL;
            continue;
        }
        //在生成第一个子句时，让S与C建立联系
        if (flag_newC && flag_clause_1st)
        {
            pc_new = (CNode *)malloc(sizeof(CNode));
            pc_new->headnode.nextL = NULL;
            pc_new->letter_num = 0;
            pc_new->nextC = NULL;
            ps->bignode.nextC = pc_new;
            ps->clause_num = sen_num;
            pc = ps->bignode.nextC;
            flag_clause_1st = 0;
            flag_newC = 0;
        }
        //要生成非首子句
        else if (flag_newC && !flag_clause_1st)
        {
            pc_new = (CNode *)malloc(sizeof(CNode));
            pc_new->headnode.nextL = NULL;
            pc_new->letter_num = 0;
            pc_new->nextC = NULL;
            pc->nextC = pc_new;
            pc = pc->nextC;
            flag_newC = 0;
        }
        //在生成子句的首文字时建立C与L的联系
        if (flag_letter_1st)
        {
            pc->headnode.nextL = pl_new;
            pc->letter_num++;
            pl = pc->headnode.nextL;
            flag_letter_1st = 0;
        }
        //将生成的文字结点纳入字句，准备下一文字的生成
        else
        {
            pl->nextL = pl_new;
            pl = pl->nextL;
            pc->letter_num++;
        }
    }
    check_clausenum(ps);
    return TRUE;
}


//cnf文件的公式解析
status Traverse(SNode S)
{
    CNode *pc = NULL;
    LNode *pl = NULL;
    if (!S.clause_num)
    {
        printf("子句集为空!\n");
        return FALSE;
    }
    pc = S.bignode.nextC;
    printf("__________字句内容如下_________\n");
    //双层循环读取子句集
    while (pc)
    {
        pl = pc->headnode.nextL;
        while (pl)
        {
            printf("%3d ", pl->data);
            pl = pl->nextL;
        }
        printf("\n");
        pc = pc->nextC;
    }
    return TRUE;
}
//cnf文件的保存
status SaveCnfFile(SNode S, char filename[100])
{

    FILE *fp = NULL;
    CNode *pc = NULL;
    LNode *pl = NULL;
    if (((fp = fopen(filename, "wb")) == NULL))
    {
        printf("File open error!\n");
        return FALSE;
    }
    else
    {
        fprintf(fp, "%s", "p cnf ");
        fprintf(fp, "%d ", var_num);
        fprintf(fp, "%d \n", sen_num);
        pc = S.bignode.nextC;
        while (pc)
        {
            pl = pc->headnode.nextL;
            while (pl)
            {
                fprintf(fp, "%d ", pl->data);
                pl = pl->nextL;
            }
            fprintf(fp, "0 \n");
            pc = pc->nextC;
        }
        fclose(fp);
        return TRUE;
    }
}

//释放链表空间
status Release_Link(SNode *ps)
{
    CNode *pc;
    LNode *pl;
    while (ps->bignode.nextC)
    {
        pc = ps->bignode.nextC;
        while (pc->headnode.nextL)
        {
            pl = pc->headnode.nextL;
            pc->headnode.nextL = pc->headnode.nextL->nextL;
            free(pl);
        }
        ps->bignode.nextC = ps->bignode.nextC->nextC;
        free(pc);
    }
    ps->clause_num = 0;
    return TRUE;
}
//新增check函数，检查子句集的子句数是否正确
void check_clausenum(SNode *ps)
{
    int count = 0;
    CNode *pc = NULL;
    pc = S.bignode.nextC;
    //双层循环读取子句集
    while (pc)
    {
        count++;
        pc = pc->nextC;
    }
    ps->clause_num = count;
}
